<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <meta name="theme-color" content="#3b82f6"/>
    <link rel="manifest" href="manifest.json" />
    <title>Pedidos Distribuidora</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/jspdf@latest/dist/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/dexie@3.2.2/dist/dexie.min.js"></script>
    <!-- Cordova specific scripts -->
    <script src="cordova.js"></script>
    <style>
        @media print {
            body, html { margin: 0; padding: 0; }
            .no-print { display: none; }
            #pdf-view { display: block !important; }
        }
        .toast-enter { opacity: 0; transform: translateY(20px); }
        .toast-enter-active { opacity: 1; transform: translateY(0); transition: opacity 300ms, transform 300ms; }
        .toast-exit { opacity: 1; transform: translateY(0); }
        .toast-exit-active { opacity: 0; transform: translateY(20px); transition: opacity 300ms, transform 300ms; }
        .sync-spin { animation: spin 1.5s linear infinite; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-100">
    <div id="root"></div>
    <div id="pdf-view" class="hidden"></div>

    <script type="text/babel">
        const { jsPDF } = window.jspdf;
        const API_URL = 'https://distriapi.onzacore.site/api';
        
        // Cordova specific configurations
        const isCordova = typeof cordova !== 'undefined';
        const checkOnlineStatus = () => navigator.onLine && (!isCordova || cordova.file.isFileSystemReady);

        // --- CONFIGURACIÓN DE LA BASE DE DATOS OFFLINE (INDEXEDDB CON DEXIE) ---
        const db = new Dexie('DistribuidoraDB');
        db.version(2).stores({
            clientes: '++local_id, id, status, retries',
            productos: '++id, imagen_blob',
            pedidos: '++local_id, status, retries',
            meta: 'key'
        });

        // --- Iconos (sin cambios) ---
        const PackageIcon = (props) => (<svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M16.5 9.4a4.5 4.5 0 1 1-9 0 4.5 4.5 0 0 1 9 0Z"/><path d="M19 13.3a9 9 0 1 1-14 0"/><path d="M12 17.5a2.5 2.5 0 0 1-2.5-2.5V9.4h5v5.6a2.5 2.5 0 0 1-2.5 2.5Z"/></svg>);
        const Spinner = ({ className }) => (<div className={`animate-spin rounded-full h-6 w-6 border-b-2 ${className || 'border-white'}`}></div>);
        const UsersIcon = (props) => (<svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg>);
        const LogOutIcon = (props) => (<svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" x2="9" y1="12" y2="12"/></svg>);
        const ArrowLeftIcon = (props) => (<svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>);
        const ShoppingCartIcon = (props) => (<svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path></svg>);
        const SyncIcon = (props) => (<svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>);
        const PlusIcon = (props) => (<svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>);
        const EditIcon = (props) => (<svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>);
        const TrashIcon = (props) => (<svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>);
        const HistoryIcon = (props) => (<svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 3v5h5"/><path d="M3.05 13A9 9 0 1 0 6 5.3L3 8"/><path d="M12 7v5l4 2"/></svg>);
        const EyeIcon = (props) => (<svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>);
        const SettingsIcon = (props) => (<svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>);
        const CloudOffIcon = (props) => (<svg {...props} xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3"/><line x1="1" y1="1" x2="23" y2="23"/></svg>);

        // --- Componentes de UI ---
        const StatusBadge = ({ status, isOrphaned }) => {
            const styles = {
                pending_sync: { text: 'Pendiente', bg: 'bg-yellow-100', text_color: 'text-yellow-800' },
                synced: { text: 'Sincronizado', bg: 'bg-green-100', text_color: 'text-green-800' },
                sync_failed: { text: 'Falló', bg: 'bg-red-100', text_color: 'text-red-800' },
                orphaned: { text: 'Huérfano', bg: 'bg-orange-100', text_color: 'text-orange-800' },
            };
            const s = styles[status] || { text: 'Desconocido', bg: 'bg-gray-100', text_color: 'text-gray-800' };
            return (
                <div className="flex items-center gap-1">
                    <span className={`px-2 inline-flex text-xs leading-5 font-semibold rounded-full ${s.bg} ${s.text_color}`}>
                        {isOrphaned ? '⚠️ ' : ''}{s.text}
                    </span>
                </div>
            );
        };
        const Toast = ({ message, type, onClose }) => {
            React.useEffect(() => {
                const timer = setTimeout(onClose, 3000);
                return () => clearTimeout(timer);
            }, [onClose]);
            const bgColor = { success: 'bg-green-500', error: 'bg-red-500', info: 'bg-blue-500'}[type] || 'bg-gray-500';
            return (<div className={`fixed bottom-4 left-1/2 transform -translate-x-1/2 ${bgColor} text-white px-4 py-2 rounded-lg shadow-lg max-w-md w-full toast-enter toast-enter-active`}>{message}</div>);
        };
        const ActionButton = ({ icon, text, onClick, badge, badgeColor }) => (
            <button onClick={onClick} className="bg-white p-4 rounded-xl shadow-md flex flex-col items-center justify-center text-center hover:bg-gray-50 active:scale-95 transition-transform relative">
                {badge > 0 && <span className={`absolute top-2 right-2 ${badgeColor} text-white text-xs font-bold rounded-full h-6 w-6 flex items-center justify-center`}>{badge}</span>}
                <div className="text-blue-600 mb-2">{React.cloneElement(icon, { className: "h-10 w-10" })}</div>
                <span className="font-semibold text-gray-700">{text}</span>
            </button>
        );

        // Componente para mostrar estado de conexión
        const ConnectionStatus = () => {
            if (!isOnline) {
                return (
                    <div className="fixed top-0 left-0 right-0 bg-red-500 text-white text-center py-2 z-50">
                        <span className="text-sm">⚠️ Modo Offline - Los datos se guardarán localmente</span>
                    </div>
                );
            }
            return null;
        };

        // --- Componentes de Modal ---
        // AGREGA este nuevo componente para notas rápidas
        const QuickNotesModal = ({ isOpen, onClose, onSave, initialNote = '' }) => {
            const [note, setNote] = React.useState(initialNote);
            
            if (!isOpen) return null;
            
            const handleSave = () => {
                if (note.trim()) {
                    onSave(note.trim());
                    setNote('');
                    onClose();
                }
            };
            
            return (
                <div className="fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50 p-4">
                    <div className="bg-white rounded-2xl shadow-xl w-full max-w-sm">
                        <div className="p-4">
                            <h3 className="font-bold text-lg mb-3">Nota Rápida</h3>
                            <textarea 
                                value={note}
                                onChange={(e) => setNote(e.target.value)}
                                placeholder="Escribe una nota para recordar..."
                                className="w-full p-3 border rounded-lg resize-none"
                                rows="4"
                                autoFocus
                            />
                        </div>
                        <div className="p-4 flex gap-2 bg-gray-50 rounded-b-2xl">
                            <button onClick={onClose} className="w-full bg-gray-200 text-gray-800 font-bold py-3 rounded-lg">
                                Cancelar
                            </button>
                            <button onClick={handleSave} className="w-full bg-blue-600 text-white font-bold py-3 rounded-lg">
                                Guardar
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const QuantityModal = ({ product, existingQuantity, onSave, onCancel }) => {
            const [quantity, setQuantity] = React.useState(existingQuantity || 1);

            const handleChange = (e) => {
                const value = e.target.value;
                if (value === '' || (/^\d*\.?\d*$/.test(value) && parseFloat(value) >= 0)) {
                    setQuantity(value);
                }
            };

            const handleSave = () => {
                const numQuantity = parseFloat(quantity);
                if (!isNaN(numQuantity) && numQuantity >= 0) {
                    onSave(product, numQuantity);
                } else {
                    alert('Por favor, ingrese una cantidad válida.');
                }
            };

            return (
                <div className="fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50 p-4">
                    <div className="bg-white rounded-2xl shadow-xl w-full max-w-sm">
                        <div className="p-4 text-center">
                            <img loading="lazy" src={product.imagen_url || 'https://placehold.co/100x100/e2e8f0/e2e8f0?text=...'} alt={product.nombre} className="w-24 h-24 rounded-lg object-cover mx-auto mb-4"/>
                            <h3 className="text-lg font-bold text-gray-800">{product.nombre}</h3>
                            <p className="text-blue-600 font-bold mb-4">${product.precio_unitario}</p>
                            <div className="flex items-center justify-center gap-4">
                                <button onClick={() => setQuantity(q => Math.max(0, parseFloat(q) - 1))} className="w-10 h-10 bg-gray-200 rounded-full font-bold text-xl">-</button>
                                <input 
                                    type="number" 
                                    step="0.1"
                                    min="0"
                                    value={quantity}
                                    onChange={handleChange}
                                    className="w-24 text-center text-2xl font-bold border-b-2 border-gray-300 focus:border-blue-500 focus:outline-none bg-transparent"
                                />
                                <button onClick={() => setQuantity(q => parseFloat(q) + 1)} className="w-10 h-10 bg-gray-200 rounded-full font-bold text-xl">+</button>
                            </div>
                        </div>
                        <div className="p-4 flex gap-2 bg-gray-50 rounded-b-2xl">
                            <button onClick={onCancel} className="w-full bg-gray-200 text-gray-800 font-bold py-3 rounded-lg">Cancelar</button>
                            <button onClick={handleSave} className="w-full bg-blue-600 text-white font-bold py-3 rounded-lg">
                                {existingQuantity > 0 ? 'Actualizar' : 'Agregar'}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Componentes de Vistas ---
        
        const VendedorHomePage = ({ user, navigateTo }) => {
            const [pendingCount, setPendingCount] = React.useState(0);
            const [badgeColor, setBadgeColor] = React.useState('bg-green-500');
            const [stats, setStats] = React.useState({
                totalPedidos: 0,
                pedidosHoy: 0,
                clientesActivos: 0,
                valorTotal: 0
            });

            React.useEffect(() => {
                const updateStats = async () => {
                    try {
                        const [pedidos, clientes] = await Promise.all([
                            db.pedidos.toArray(),
                            db.clientes.toArray()
                        ]);
                        
                        const hoy = new Date().toDateString();
                        const pedidosHoy = pedidos.filter(p => 
                            new Date(p.fecha).toDateString() === hoy
                        );
                        
                        // Calcular valor total (aproximado)
                        const valorTotal = pedidos.reduce((total, pedido) => {
                            return total + pedido.items.reduce((itemTotal, item) => {
                                return itemTotal + (item.precio_congelado || 0) * item.cantidad;
                            }, 0);
                        }, 0);
                        
                        setStats({
                            totalPedidos: pedidos.length,
                            pedidosHoy: pedidosHoy.length,
                            clientesActivos: clientes.filter(c => !c.is_orphaned).length,
                            valorTotal: valorTotal
                        });
                    } catch (error) {
                        console.error('Error calculando estadísticas:', error);
                    }
                };
                
                const interval = setInterval(async () => {
                    const pendingSyncCount = await db.pedidos.where('status').equals('pending_sync').count();
                    setPendingCount(pendingSyncCount);
                    setBadgeColor(pendingSyncCount > 0 ? 'bg-yellow-500' : 'bg-green-500');
                    updateStats();
                }, 1000);
                
                return () => clearInterval(interval);
            }, []);

            return (
                <div className="bg-white min-h-screen">
                    <header className="bg-blue-600 text-white p-4 shadow-md sticky top-0 z-10">
                        <div className="flex justify-between items-center">
                            <div className="flex items-center gap-3">
                                <h1 className="text-xl font-bold">{user ? `Hola, ${user.nombre}` : 'Modo Offline'}</h1>
                                {offlineMode && (
                                    <div className="flex items-center gap-1 bg-yellow-500 text-yellow-900 px-2 py-1 rounded-full text-xs font-medium">
                                        <CloudOffIcon className="h-4 w-4"/>
                                        Offline
                                    </div>
                                )}
                            </div>
                            <button onClick={() => navigateTo('config')} title="Configuración"><SettingsIcon className="h-6 w-6"/></button>
                        </div>
                    </header>
                    
                    {/* Panel de estadísticas */}
                    <div className="p-4 bg-gradient-to-r from-blue-50 to-indigo-50">
                        <h2 className="text-lg font-bold text-gray-800 mb-3">Resumen del Día</h2>
                        <div className="grid grid-cols-2 gap-3">
                            <div className="bg-white p-3 rounded-lg shadow-sm">
                                <p className="text-sm text-gray-600">Pedidos Hoy</p>
                                <p className="text-2xl font-bold text-blue-600">{stats.pedidosHoy}</p>
                            </div>
                            <div className="bg-white p-3 rounded-lg shadow-sm">
                                <p className="text-sm text-gray-600">Total Pedidos</p>
                                <p className="text-2xl font-bold text-green-600">{stats.totalPedidos}</p>
                            </div>
                            <div className="bg-white p-3 rounded-lg shadow-sm">
                                <p className="text-sm text-gray-600">Clientes Activos</p>
                                <p className="text-2xl font-bold text-purple-600">{stats.clientesActivos}</p>
                            </div>
                            <div className="bg-white p-3 rounded-lg shadow-sm">
                                <p className="text-sm text-gray-600">Valor Total</p>
                                <p className="text-xl font-bold text-orange-600">${stats.valorTotal.toFixed(2)}</p>
                            </div>
                        </div>
                    </div>
                    
                    <main className="p-4 grid grid-cols-2 gap-4">
                        <ActionButton icon={<UsersIcon/>} text="Clientes" onClick={() => navigateTo('clientes')} />
                        <ActionButton icon={<ShoppingCartIcon/>} text="Pedidos" onClick={() => navigateTo('pendientes')} badge={pendingCount} badgeColor={badgeColor} />
                    </main>
                    
                    {/* Botón flotante para notas rápidas */}
                    <button 
                        onClick={() => setShowQuickNotes(true)}
                        className="fixed bottom-6 right-6 bg-blue-600 text-white p-4 rounded-full shadow-lg hover:bg-blue-700 active:scale-95 transition-transform"
                        title="Nota Rápida"
                    >
                        <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path>
                        </svg>
                    </button>
                </div>
            );
        };

        const ConfiguracionView = ({ onBack, onLogout, user, onSync, lastSyncTime, syncInProgress }) => {
            return (
                <div className="bg-gray-100 min-h-screen">
                    <header className="bg-white p-4 shadow-md sticky top-0 flex items-center gap-4 z-10">
                        <button onClick={onBack} className="text-blue-600"><ArrowLeftIcon className="h-6 w-6"/></button>
                        <h2 className="font-bold text-lg">Configuración y Sincronización</h2>
                    </header>
                    <main className="p-4 space-y-6">
                        <div className="bg-white p-4 rounded-lg shadow">
                            <h3 className="font-bold text-gray-800">Estado de la Cuenta</h3>
                            {user ? (
                                <>
                                    <p className="text-gray-600 mt-2">Conectado como: <span className="font-semibold text-blue-600">{user.nombre}</span></p>
                                    <p className="text-sm text-gray-500 mt-1">Última sincronización: {lastSyncTime ? new Date(lastSyncTime).toLocaleString() : 'Nunca'}</p>
                                    <button onClick={onLogout} className="w-full mt-4 bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg flex items-center justify-center gap-2">
                                        <LogOutIcon className="h-5 w-5"/> Cerrar Sesión
                                    </button>
                                </>
                            ) : (
                                <>
                                    <div className="flex items-center gap-3 mt-2 text-yellow-700">
                                        <CloudOffIcon className="h-8 w-8"/>
                                        <p>No has iniciado sesión. Tus pedidos se guardan en este dispositivo.</p>
                                    </div>
                                    <button onClick={() => onBack('login')} className="w-full mt-4 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">
                                        Iniciar Sesión para Sincronizar
                                    </button>
                                </>
                            )}
                        </div>
                        <div className="bg-white p-4 rounded-lg shadow">
                            <h3 className="font-bold text-gray-800">Sincronización de Datos</h3>
                            <p className="text-sm text-gray-500 mt-1">Sube tus pedidos pendientes y descarga las listas actualizadas de clientes y productos.</p>
                            <button onClick={onSync} disabled={!user || syncInProgress} className="w-full mt-4 bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center gap-2 disabled:bg-gray-400 disabled:cursor-not-allowed">
                                {syncInProgress ? <Spinner className="border-white h-5 w-5"/> : <SyncIcon className={`h-5 w-5 ${syncInProgress ? 'sync-spin' : ''}`}/>}
                                {syncInProgress ? 'Sincronizando...' : 'Sincronizar Agora'}
                            </button>
                            {!user && <p className="text-xs text-red-500 mt-2 text-center">Debes iniciar sesión para poder sincronizar.</p>}
                        </div>
                    </main>
                </div>
            );
        };

        const LoginPage = ({ onLogin, loading, error, onBack }) => {
            const [email, setEmail] = React.useState('');
            const [password, setPassword] = React.useState('');
            
            const handleSubmit = (e) => {
                e.preventDefault();
                onLogin(email, password);
            };

            return (
                <div className="min-h-screen bg-blue-600 flex flex-col justify-center items-center p-4 font-sans">
                    <div className="w-full max-w-sm">
                        <div className="bg-white rounded-2xl shadow-lg p-8 relative">
                            <button onClick={onBack} className="absolute top-4 left-4 text-gray-400 hover:text-gray-600"><ArrowLeftIcon/></button>
                            <div className="text-center mb-6"><PackageIcon className="h-16 w-16 text-blue-600 mx-auto" /><h1 className="text-2xl font-bold text-gray-800 mt-2">Iniciar Sesión</h1><p className="text-gray-500">Sincroniza tus datos con la nube.</p></div>
                            <form onSubmit={handleSubmit}>
                                <div className="mb-5"><label className="block text-gray-700 text-sm font-bold mb-2" htmlFor="email">Correo</label><input id="email" type="email" value={email} onChange={(e) => setEmail(e.target.value)} placeholder="tu@email.com" className="w-full px-4 py-3 rounded-lg bg-gray-100 focus:border-blue-500 focus:bg-white focus:outline-none" required /></div>
                                <div className="mb-6"><label className="block text-gray-700 text-sm font-bold mb-2" htmlFor="password">Contraseña</label><input id="password" type="password" value={password} onChange={(e) => setPassword(e.target.value)} placeholder="••••••••••" className="w-full px-4 py-3 rounded-lg bg-gray-100 focus:border-blue-500 focus:bg-white focus:outline-none" required /></div>
                                {error && <p className="text-red-500 text-xs italic mb-4 text-center">{error}</p>}
                                <button type="submit" disabled={loading} className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center text-lg">{loading ? <Spinner /> : 'Ingresar y Sincronizar'}</button>
                            </form>
                        </div>
                    </div>
                </div>
            );
        };

        const ClientesView = ({ onBack, onSelectCliente, onAddCliente }) => {
            const [clientes, setClientes] = React.useState([]);
            const [loading, setLoading] = React.useState(true);
            const [searchTerm, setSearchTerm] = React.useState('');

            React.useEffect(() => {
                const fetchClientes = async () => {
                    setLoading(true);
                    try {
                        const data = await db.clientes.where('nombre_comercio').startsWithIgnoreCase(searchTerm).toArray();
                        setClientes(data);
                    } catch (error) {
                        console.error("Error al cargar clientes desde Dexie:", error);
                    } finally {
                        setLoading(false);
                    }
                };
                fetchClientes();
            }, [searchTerm]);



            return (
                <div className="bg-gray-100 min-h-screen">
                    <header className="bg-white p-4 shadow-md sticky top-0 flex items-center gap-4 z-10">
                        <button onClick={onBack} className="text-blue-600"><ArrowLeftIcon className="h-6 w-6"/></button>
                        <input type="text" placeholder="Buscar cliente..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="w-full px-4 py-2 rounded-lg bg-gray-200 focus:outline-none"/>
                        <button onClick={onAddCliente} className="p-2 bg-green-500 text-white rounded-full flex-shrink-0"><PlusIcon className="h-6 w-6"/></button>
                    </header>
                    <main className="p-4">
                        {loading && <div className="text-center py-10"><Spinner className="border-blue-600 h-8 w-8 mx-auto"/></div>}
                        {!loading && clientes.length > 0 && (
                            <div className="space-y-3">
                                {clientes.map(cliente => (
                                    <div key={cliente.local_id} onClick={() => onSelectCliente(cliente)} className="bg-white p-4 rounded-lg shadow mb-3 flex justify-between items-center cursor-pointer active:bg-gray-200">
                                        <div className="flex-1">
                                            <p className="font-bold text-gray-800">{cliente.nombre_comercio}</p>
                                            <p className="text-sm text-gray-600">{cliente.direccion}</p>
                                        </div>
                                        {cliente.status === 'pending_sync' && <StatusBadge status="pending_sync" />}
                                    </div>
                                ))}
                            </div>
                        )}
                        {!loading && clientes.length === 0 && (
                            <p className="text-center text-gray-500 mt-8">No se encontraron clientes.</p>
                        )}
                    </main>
                </div>
            );
        };

        // REEMPLAZA el componente ClienteFormView existente
        const ClienteFormView = ({ onBack, cliente, onSave }) => {
            const [formData, setFormData] = React.useState({
                nombre_comercio: '',
                nombre_contacto: '',
                direccion: '',
                telefono: ''
            });
            const isEditing = cliente !== null;

            React.useEffect(() => {
                if (isEditing) {
                    setFormData(cliente);
                } else {
                    // Reinicia el formulario para un cliente nuevo
                    setFormData({ nombre_comercio: '', nombre_contacto: '', direccion: '', telefono: '' });
                }
            }, [cliente, isEditing]);

            const handleChange = (e) => {
                const { name, value } = e.target;
                setFormData(prev => ({ ...prev, [name]: value }));
            };

            const handleSubmit = (e) => {
                e.preventDefault();
                onSave(formData);
            };

            return (
                <div className="bg-gray-100 min-h-screen">
                    <header className="bg-white p-4 shadow-md sticky top-0 flex items-center gap-4 z-10">
                        <button onClick={onBack} className="text-blue-600"><ArrowLeftIcon className="h-6 w-6"/></button>
                        <h2 className="font-bold text-lg">{isEditing ? 'Editar Cliente' : 'Nuevo Cliente'}</h2>
                    </header>
                    <main className="p-4">
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <div><label className="text-sm font-medium">Nombre del Comercio</label><input type="text" name="nombre_comercio" value={formData.nombre_comercio} onChange={handleChange} className="w-full p-2 border rounded-lg mt-1" required /></div>
                            <div><label className="text-sm font-medium">Nombre del Contacto</label><input type="text" name="nombre_contacto" value={formData.nombre_contacto} onChange={handleChange} className="w-full p-2 border rounded-lg mt-1" /></div>
                            <div><label className="text-sm font-medium">Dirección</label><input type="text" name="direccion" value={formData.direccion} onChange={handleChange} className="w-full p-2 border rounded-lg mt-1" /></div>
                            <div><label className="text-sm font-medium">Teléfono</label><input type="text" name="telefono" value={formData.telefono} onChange={handleChange} className="w-full p-2 border rounded-lg mt-1" /></div>
                            <button type="submit" className="w-full bg-green-500 text-white font-bold py-3 rounded-lg mt-4">Guardar Cliente</button>
                        </form>
                    </main>
                </div>
            );
        };  

        // REEMPLAZA el componente PedidoView existente
        const PedidoView = ({ cliente, onBack, onShowCart, cart, onProductSelect }) => {
            const [productos, setProductos] = React.useState([]);
            const [loading, setLoading] = React.useState(true);
            const [searchTerm, setSearchTerm] = React.useState('');

            // Lee la lista de productos desde la base de datos local
            React.useEffect(() => {
                const fetchProductos = async () => {
                    setLoading(true);
                    try {
                        const data = await db.productos.orderBy('nombre').toArray();
                        setProductos(data);
                    } catch (error) {
                        console.error("Error al cargar productos desde Dexie:", error);
                    } finally {
                        setLoading(false);
                    }
                };
                fetchProductos();
            }, []);

            const filteredProductos = productos.filter(p => 
                p.nombre.toLowerCase().includes(searchTerm.toLowerCase())
            );

            const totalPedido = cart.reduce((acc, item) => acc + (item.producto.precio_unitario * item.cantidad), 0);

            return (
                <div className="flex flex-col h-screen bg-gray-100">
                    <header className="bg-white p-4 shadow-md sticky top-0 flex items-center gap-4 z-10">
                        <button onClick={() => onBack(cart)} className="text-blue-600"><ArrowLeftIcon className="h-6 w-6"/></button>
                        <div>
                            <h2 className="font-bold text-lg">{cliente.nombre_comercio}</h2>
                            <p className="text-xs text-gray-500">Nuevo Pedido</p>
                        </div>
                    </header>
                    <div className="p-4">
                        <input type="text" placeholder="Buscar producto..." value={searchTerm} onChange={e => setSearchTerm(e.target.value)} className="w-full px-4 py-2 mb-4 border rounded-lg"/>
                    </div>
                    <main className="flex-1 overflow-y-auto p-4 pt-0 pb-24">
                        {loading && <div className="text-center py-10"><Spinner className="border-blue-600 h-8 w-8 mx-auto"/></div>}
                        {!loading && filteredProductos.map(producto => {
                            const itemInCart = cart.find(item => item.producto.id === producto.id);
                            return (
                                <div key={producto.id} onClick={() => onProductSelect(producto)} className="bg-white p-3 rounded-lg shadow mb-3 flex items-center gap-4 active:bg-gray-200 cursor-pointer">
                                    <img loading="lazy" src={producto.imagen_url || 'https://placehold.co/100x100/e2e8f0/e2e8f0?text=...'} alt={producto.nombre} className="w-16 h-16 rounded-md object-cover"/>
                                    <div className="flex-1">
                                        <p className="font-semibold text-gray-800">{producto.nombre}</p>
                                        <p className="text-sm text-blue-600 font-bold">${producto.precio_unitario}</p>
                                        <p className={`text-xs font-bold ${producto.stock === 1 ? 'text-green-500' : 'text-red-500'}`}>
                                            Stock: {producto.stock === 1 ? 'Sí' : 'No'}
                                        </p>
                                    </div>
                                    {itemInCart && (
                                        <div className="bg-blue-600 text-white rounded-full h-8 w-8 flex items-center justify-center font-bold text-sm">
                                            {itemInCart.cantidad}
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                    </main>
                    {cart.length > 0 && (
                        <footer className="bg-white p-4 shadow-inner fixed bottom-0 w-full border-t">
                            <button onClick={() => onShowCart(cart)} className="w-full bg-blue-600 text-white font-bold py-3 rounded-lg flex justify-between items-center px-4">
                                <div className="flex items-center gap-2"><ShoppingCartIcon className="h-6 w-6"/><span>{cart.reduce((acc, item) => acc + item.cantidad, 0)} items</span></div>
                                <span>Ver Pedido</span><span>${totalPedido.toFixed(2)}</span>
                            </button>
                        </footer>
                    )}
                </div>
            );
        };

        // REEMPLAZA el componente PedidoSummaryView existente
        const PedidoSummaryView = ({ cliente, pedido, setPedido, onBack, onSave, onAddMoreProducts, editingPedido, onCancelEdit }) => {
            const [notas, setNotas] = React.useState(editingPedido ? editingPedido.notas_entrega : '');

            const updateCantidad = (productoId, cantidadStr) => {
                const cantidad = parseFloat(String(cantidadStr).replace(',', '.'));
                setPedido(currentPedido => {
                    if (isNaN(cantidad) || cantidad <= 0) {
                        return currentPedido.filter(item => item.producto.id !== productoId);
                    }
                    return currentPedido.map(item => item.producto.id === productoId ? { ...item, cantidad: cantidad } : item);
                });
            };

            const totalPedido = pedido.reduce((acc, item) => acc + (item.producto.precio_unitario * item.cantidad), 0);

            return (
                <div className="flex flex-col h-screen bg-gray-100">
                    <header className="bg-white p-4 shadow-md sticky top-0 flex items-center gap-4 z-10">
                        <button onClick={() => onBack(pedido)} className="text-blue-600"><ArrowLeftIcon className="h-6 w-6"/></button>
                        <div>
                            <h2 className="font-bold text-lg">{editingPedido ? 'Editar Pedido' : 'Revisar Pedido'}</h2>
                            <p className="text-xs text-gray-500">{cliente.nombre_comercio}</p>
                        </div>
                    </header>
                    <main className="flex-1 overflow-y-auto p-4">
                        <button onClick={() => onAddMoreProducts(pedido)} className="w-full bg-blue-100 text-blue-800 font-semibold py-3 rounded-lg mb-4 flex items-center justify-center gap-2">
                            <PlusIcon className="h-5 w-5"/> Agregar más productos
                        </button>
                        {pedido.map(item => (
                            <div key={item.producto.id} className="bg-white p-3 rounded-lg shadow mb-3 flex items-center gap-4">
                                <img loading="lazy" src={item.producto.imagen_url || 'https://placehold.co/100x100/e2e8f0/e2e8f0?text=...'} alt={item.producto.nombre} className="w-12 h-12 rounded-md object-cover"/>
                                <div className="flex-1">
                                    <p className="font-semibold text-gray-800 text-sm">{item.producto.nombre}</p>
                                    <p className="text-xs text-gray-500">${item.producto.precio_unitario} c/u</p>
                                </div>
                                <div className="flex items-center gap-3">
                                    <label className="text-sm font-medium">Cant:</label>
                                    <input type="text" inputMode="decimal" value={item.cantidad} onChange={(e) => updateCantidad(item.producto.id, e.target.value)} className="w-20 text-center border-gray-300 border rounded-lg p-1 bg-transparent" min="0" />
                                </div>
                            </div>
                        ))}
                        <div className="mt-4">
                            <label htmlFor="notas" className="block text-sm font-medium text-gray-700 mb-1">Notas para la entrega</label>
                            <textarea id="notas" value={notas} onChange={e => setNotas(e.target.value)} rows="3" className="w-full p-2 border rounded-lg" placeholder="Ej: Dejar en el depósito del fondo..."></textarea>
                        </div>
                    </main>
                    <footer className="bg-white p-4 shadow-inner sticky bottom-0 border-t">
                        <div className="flex justify-between items-center font-bold text-xl mb-3">
                            <span>Total:</span>
                            <span>${totalPedido.toFixed(2)}</span>
                        </div>
                        <div className="flex gap-2">
                            {/* MEJORA: Se muestra el botón de cancelar solo en modo edición */}
                            {editingPedido && (
                                <button onClick={onCancelEdit} className="w-full bg-gray-500 text-white font-bold py-3 rounded-lg">Descartar Cambios</button>
                            )}
                            <button onClick={() => onSave(notas)} disabled={pedido.length === 0} className="w-full bg-green-500 text-white font-bold py-3 rounded-lg disabled:bg-gray-400">
                                {editingPedido ? 'Guardar Cambios' : 'Confirmar Pedido'}
                            </button>
                        </div>
                    </footer>
                </div>
            );
        };

        // AGREGA O REEMPLAZA el componente PedidosPendientesView
        const PedidosPendientesView = ({ onBack, onSync, onEditPedido, onViewPedido, onDeletePedido, user, onLoginRequest, isSyncing }) => {
            const [pedidos, setPedidos] = React.useState([]);
            const [clientes, setClientes] = React.useState([]);
            const [searchTerm, setSearchTerm] = React.useState('');
            const [statusFilter, setStatusFilter] = React.useState('all');

            // Leemos tanto los pedidos como los clientes para poder cruzarlos
            React.useEffect(() => {
                const fetchData = async () => {
                    const [pedidosData, clientesData] = await Promise.all([
                        db.pedidos.orderBy('fecha').reverse().toArray(),
                        db.clientes.toArray()
                    ]);
                    setPedidos(pedidosData);
                    setClientes(clientesData);
                };
                fetchData();
            }, [isSyncing]); // Se actualiza la lista cada vez que termina una sincronización

            const getClienteNombre = (pedido) => {
                // Lógica inteligente: busca por ID de servidor, y si no, por ID local.
                const cliente = clientes.find(c => (c.id && c.id === pedido.cliente_id) || c.local_id === pedido.cliente_local_id);
                if (!cliente) return 'Cliente no encontrado';
                
                // Si es un cliente huérfano, mostrar indicador especial
                if (cliente.is_orphaned) {
                    return `⚠️ ${cliente.nombre_comercio}`;
                }
                return cliente.nombre_comercio;
            };

            const handleDelete = (pedidoId) => {
                if (window.confirm('¿Estás seguro de que quieres eliminar este pedido? Esta acción no se puede deshacer.')) {
                    onDeletePedido(pedidoId);
                    setPedidos(current => current.filter(p => p.local_id !== pedidoId));
                }
            };

            // Filtrado inteligente de pedidos
            const filteredPedidos = pedidos.filter(pedido => {
                const cliente = clientes.find(c => (c.id && c.id === pedido.cliente_id) || c.local_id === pedido.cliente_local_id);
                const clienteNombre = cliente?.nombre_comercio || '';
                
                // Filtro por texto de búsqueda
                const matchesSearch = searchTerm === '' || 
                    clienteNombre.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    (pedido.notas_entrega && pedido.notas_entrega.toLowerCase().includes(searchTerm.toLowerCase()));
                
                // Filtro por estado
                const matchesStatus = statusFilter === 'all' || pedido.status === statusFilter;
                
                return matchesSearch && matchesStatus;
            });

            return (
                <div className="bg-gray-100 min-h-screen">
                    <header className="bg-white p-4 shadow-md sticky top-0 flex items-center justify-between z-10">
                        <div className="flex items-center gap-4">
                            <button onClick={onBack} className="text-blue-600"><ArrowLeftIcon className="h-6 w-6"/></button>
                            <h2 className="font-bold text-lg">Pedidos Guardados</h2>
                        </div>
                        <button onClick={onSync} disabled={isSyncing} className="bg-green-500 text-white font-bold py-2 px-4 rounded-lg flex items-center gap-2 disabled:bg-gray-400">
                            {isSyncing ? <Spinner className="border-white h-5 w-5"/> : <SyncIcon className="h-5 w-5"/>}
                            {user ? 'Sincronizar' : 'Iniciar Sesión'}
                        </button>
                    </header>
                    
                    {/* Filtros de búsqueda */}
                    <div className="p-4 bg-white border-b">
                        <div className="flex gap-2 mb-3">
                            <input 
                                type="text" 
                                placeholder="Buscar por cliente o notas..." 
                                value={searchTerm} 
                                onChange={(e) => setSearchTerm(e.target.value)}
                                className="flex-1 px-3 py-2 border rounded-lg"
                            />
                        </div>
                        <div className="flex gap-2">
                            <button 
                                onClick={() => setStatusFilter('all')}
                                className={`px-3 py-1 rounded-lg text-sm font-medium ${statusFilter === 'all' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700'}`}
                            >
                                Todos ({pedidos.length})
                            </button>
                            <button 
                                onClick={() => setStatusFilter('pending_sync')}
                                className={`px-3 py-1 rounded-lg text-sm font-medium ${statusFilter === 'pending_sync' ? 'bg-yellow-600 text-white' : 'bg-gray-200 text-gray-700'}`}
                            >
                                Pendientes ({pedidos.filter(p => p.status === 'pending_sync').length})
                            </button>
                            <button 
                                onClick={() => setStatusFilter('sync_failed')}
                                className={`px-3 py-1 rounded-lg text-sm font-medium ${statusFilter === 'sync_failed' ? 'bg-red-600 text-white' : 'bg-gray-200 text-gray-700'}`}
                            >
                                Fallidos ({pedidos.filter(p => p.status === 'sync_failed').length})
                            </button>
                        </div>
                    </div>
                    
                    <main className="p-4">
                        {filteredPedidos.length === 0 && !isSyncing && (
                            <div className="text-center py-8">
                                <p className="text-gray-500 mb-2">
                                    {searchTerm || statusFilter !== 'all' ? 'No se encontraron pedidos con los filtros aplicados.' : 'No hay pedidos guardados en el dispositivo.'}
                                </p>
                                {(searchTerm || statusFilter !== 'all') && (
                                    <button 
                                        onClick={() => { setSearchTerm(''); setStatusFilter('all'); }}
                                        className="text-blue-600 font-medium"
                                    >
                                        Limpiar filtros
                                    </button>
                                )}
                            </div>
                        )}
                        {filteredPedidos.map(p => {
                            const cliente = clientes.find(c => (c.id && c.id === p.cliente_id) || c.local_id === p.cliente_local_id);
                            const isOrphaned = cliente?.is_orphaned;
                            
                            return (
                                <div key={p.local_id} className={`bg-white p-4 rounded-lg shadow mb-3 flex justify-between items-center ${isOrphaned ? 'border-l-4 border-orange-500' : ''}`}>
                                    <div>
                                        <p className="font-bold text-gray-800">{getClienteNombre(p)}</p>
                                        <p className="text-sm text-gray-600">{p.items.length} items</p>
                                        <p className="text-xs text-gray-400">Creado: {new Date(p.fecha).toLocaleString()}</p>
                                        <StatusBadge status={p.status} isOrphaned={isOrphaned} />
                                    </div>
                                    <div className="flex gap-2">
                                        <button onClick={() => onViewPedido(p)} className="text-gray-400 hover:text-blue-600 p-2"><EyeIcon className="h-5 w-5"/></button>
                                        {p.status !== 'synced' && (
                                            <>
                                                <button onClick={() => onEditPedido(p)} className="text-gray-400 hover:text-blue-600 p-2"><EditIcon className="h-5 w-5"/></button>
                                                <button onClick={() => handleDelete(p.local_id)} className="text-gray-400 hover:text-red-600 p-2"><TrashIcon className="h-5 w-5"/></button>
                                            </>
                                        )}
                                    </div>
                                </div>
                            );
                        })}
                    </main>
                </div>
            );
        };

        const HistorialClienteView = ({ cliente, onBack, onViewPedido }) => {
            const [pedidos, setPedidos] = React.useState([]);
            const [productos, setProductos] = React.useState([]);

            React.useEffect(() => {
                const fetchData = async () => {
                    const clientesData = await db.clientes.toArray();
                    const productosData = await db.productos.toArray();
                    const pedidosDelCliente = (await db.pedidos.where({ cliente_id: cliente.id }).toArray())
                        .sort((a, b) => new Date(b.fecha) - new Date(a.fecha));
                    setPedidos(pedidosDelCliente);
                    setProductos(productosData);
                };
                fetchData();
            }, [cliente.id]);

            const calcularTotal = (items) => {
                return items.reduce((total, item) => {
                    const producto = productos.find(p => p.id === item.producto_id);
                    return total + (producto ? producto.precio_unitario * item.cantidad : 0);
                }, 0).toFixed(2);
            };

            return (
                <div className="bg-gray-100 min-h-screen">
                    <header className="bg-white p-4 shadow-md sticky top-0 flex items-center gap-4 z-10">
                        <button onClick={onBack} className="text-blue-600"><ArrowLeftIcon className="h-6 w-6"/></button>
                        <div>
                            <h2 className="font-bold text-lg">Historial de Pedidos</h2>
                            <p className="text-xs text-gray-500">{cliente.nombre_comercio}</p>
                        </div>
                    </header>
                    <main className="p-4">
                        {pedidos.length === 0 ? (
                            <p className="text-center text-gray-500 mt-8">No hay pedidos guardados para este cliente.</p>
                        ) : (
                            pedidos.map(pedido => (
                                <div key={pedido.id_local} className="bg-white p-4 rounded-lg shadow mb-3 cursor-pointer" onClick={() => onViewPedido(pedido)}>
                                    <div className="flex justify-between items-center mb-2 pb-2 border-b">
                                        <div>
                                            <p className="font-bold text-gray-800">Pedido del {new Date(pedido.fecha).toLocaleDateString()}</p>
                                            <StatusBadge status={pedido.status} />
                                        </div>
                                        <p className="font-semibold text-blue-600">Total: ${calcularTotal(pedido.items)}</p>
                                    </div>
                                    <div className="text-center mt-2">
                                        <button className="text-blue-600 font-semibold text-sm">Ver Detalles</button>
                                    </div>
                                </div>
                            ))
                        )}
                    </main>
                </div>
            );
        };

        const PedidoDetailView = ({ pedido, onBack }) => {
            const [productos, setProductos] = React.useState([]);
            React.useEffect(() => {
                const fetchData = async () => {
                    const clientesData = await db.clientes.toArray();
                    const productosData = await db.productos.toArray();
                    const pedidosDelCliente = (await db.pedidos.where({ cliente_id: cliente.id }).toArray())
                        .sort((a, b) => new Date(b.fecha) - new Date(a.fecha));
                    setPedidos(pedidosDelCliente);
                    setProductos(productosData);
                };
                fetchData();
            }, [cliente.id]);

            return (
                <div className="bg-gray-100 min-h-screen">
                    <header className="bg-white p-4 shadow-md sticky top-0 flex items-center gap-4 z-10">
                        <button onClick={onBack} className="text-blue-600"><ArrowLeftIcon className="h-6 w-6"/></button>
                        <h2 className="font-bold text-lg">Detalles del Pedido</h2>
                    </header>
                    <main className="p-4">
                        <div className="bg-white p-4 rounded-lg shadow mb-4">
                            <p className="font-bold text-gray-800">{JSON.parse(localStorage.getItem('clientes') || '[]').find(c => c.id === pedido.cliente_id)?.nombre_comercio || 'Cliente no encontrado'}</p>
                            <p className="text-sm text-gray-600">Creado: {new Date(pedido.fecha).toLocaleString()}</p>
                            <p className="text-sm text-gray-600">Notas: {pedido.notas_entrega || 'Sin notas'}</p>
                            <StatusBadge status={pedido.status} />
                        </div>
                        {pedido.items.map(item => {
                            const producto = productos.find(p => p.id === item.producto_id);
                            return (
                                <div key={item.producto_id} className="bg-white p-3 rounded-lg shadow mb-3 flex items-center gap-4">
                                    <img loading="lazy" src={producto?.imagen_url || 'https://placehold.co/100x100/e2e8f0/e2e8f0?text=...'} alt={producto?.nombre} className="w-12 h-12 rounded-md object-cover"/>
                                    <div className="flex-1">
                                        <p className="font-semibold text-gray-800 text-sm">{producto?.nombre || 'Producto no encontrado'}</p>
                                        <p className="text-xs text-gray-500">${producto?.precio_unitario || 0} x {item.cantidad} = ${( (producto?.precio_unitario || 0) * item.cantidad).toFixed(2)}</p>
                                    </div>
                                </div>
                            );
                        })}
                        <div className="bg-white p-4 rounded-lg shadow">
                            <div className="flex justify-between items-center font-bold text-xl">
                                <span>Total:</span>
                                <span>${total.toFixed(2)}</span>
                            </div>
                        </div>
                    </main>
                </div>
            );
        };

        // REEMPLAZA el componente App entero por esta versión final
        function App() {

            const [syncProgress, setSyncProgress] = React.useState({ clientes: { current: 0, total: 0 }, pedidos: { current: 0, total: 0 }, total: 0 });
            // --- ESTADO DE LA APLICACIÓN ---
            const [user, setUser] = React.useState(null);
            const [lastSyncTime, setLastSyncTime] = React.useState(null);
            const [isSyncing, setIsSyncing] = React.useState(false);
                            const [isOnline, setIsOnline] = React.useState(checkOnlineStatus());
            const [pendingCount, setPendingCount] = React.useState(0);
            
            const [pageHistory, setPageHistory] = React.useState(['loading']);
            const currentPage = pageHistory[pageHistory.length - 1];

            // Estados para manejar la navegación y datos seleccionados
            const [selectedCliente, setSelectedCliente] = React.useState(null);
            const [editingCliente, setEditingCliente] = React.useState(null);
            const [currentPedido, setCurrentPedido] = React.useState([]); // Este es el "carrito" o "memoria temporal"
            const [editingPedido, setEditingPedido] = React.useState(null); // Guarda el pedido original que se está editando
            const [productForQuantity, setProductForQuantity] = React.useState(null);
            const [selectedPedido, setSelectedPedido] = React.useState(null);
            const [toast, setToast] = React.useState(null);
            const [showQuickNotes, setShowQuickNotes] = React.useState(false);

            // --- NAVEGACIÓN ---
            const navigateTo = (page) => setPageHistory(prev => [...prev, page]);
            const navigateBack = () => {
                if (pageHistory.length > 1) {
                    const newHistory = pageHistory.slice(0, -1);
                    setPageHistory(newHistory);
                    window.history.pushState({ page: newHistory[newHistory.length - 1] }, '', `#${newHistory[newHistory.length - 1]}`);
                }
            };
            
            React.useEffect(() => {
                const handleBackButton = (e) => { e.preventDefault(); navigateBack(); };
                window.addEventListener('popstate', handleBackButton);
                return () => window.removeEventListener('popstate', handleBackButton);
            }, []);

            // REEMPLAZA el primer hook useEffect del componente App por esta versión robusta

            React.useEffect(() => {
                const initApp = async () => {
                    try {
                        // Intenta cargar los datos de sesión desde la base de datos local
                        const savedUser = await db.meta.get('user');
                        const savedSyncTime = await db.meta.get('lastSyncTime');

                        if (savedUser) {
                            setUser(savedUser.value);
                        }
                        if (savedSyncTime) {
                            setLastSyncTime(savedSyncTime.value);
                        }

                        // Disparador de Sincronización #1: Al iniciar la app (con un pequeño delay)
                        // Lo intentará, pero la función handleSync ya está preparada para no hacer nada si no hay conexión.
                        setTimeout(handleSync, 2000);

                        // Disparador de Sincronización #2: Periódicamente (cada 30 minutos)
                        const intervalId = setInterval(handleSync, 30 * 60 * 1000);

                        // Disparador de Sincronización #3: Al recuperar/perder conexión
                        const handleOnline = () => { setIsOnline(true); handleSync(); };
                        const handleOffline = () => setIsOnline(false);
                        window.addEventListener('online', handleOnline);
                        window.addEventListener('offline', handleOffline);

                        // Si todo sale bien, decidimos a qué página ir
                        setPageHistory(savedUser ? ['home'] : ['login']);
                        
                        // Limpiar todo al cerrar la app
                        return () => {
                            clearInterval(intervalId);
                            window.removeEventListener('online', handleOnline);
                            window.removeEventListener('offline', handleOffline);
                        };

                    } catch (error) {
                        // Si cualquier cosa en el bloque 'try' falla...
                        console.error("Error crítico durante la inicialización de la app:", error);
                        setToast({ message: 'Error al iniciar. Revisa tu conexión o datos locales.', type: 'error' });
                        // ...lo mandamos a la pantalla de login como último recurso seguro.
                        setPageHistory(['login']);
                    }
                };

                initApp();
            }, []); // El array vacío asegura que esto se ejecute solo una vez al arrancar

            // Hook para mantener actualizado el contador de pedidos pendientes
            React.useEffect(() => {
                const updateCounter = async () => {
                    const count = await db.pedidos.where('status').equals('pending_sync').count();
                    setPendingCount(count);
                };
                const interval = setInterval(updateCounter, 3000); // Revisa cada 3 segundos
                return () => clearInterval(interval);
            }, []);

            // --- NUEVO: MANEJO DE SESIÓN CON BASE DE DATOS LOCAL ---
            const handleLogin = async (email, password) => {
                setIsSyncing(true); // Usamos el estado de sync para el login
                setToast(null);
                try {
                    const loginResponse = await fetch(`${API_URL}/auth/login`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ email, password }) });
                    const data = await loginResponse.json();
                    if (!loginResponse.ok) throw new Error(data.message || 'Error al iniciar sesión.');
                    
                    // Guardar sesión en la base de datos local
                    await db.meta.bulkPut([
                        { key: 'token', value: data.token },
                        { key: 'user', value: data.user }
                    ]);
                    setUser(data.user);
                    
                    await handleSync(); // Sincroniza todo inmediatamente después de iniciar sesión
                    setPageHistory(['home']);
                } catch (err) {
                    setToast({ message: err.message, type: 'error' });
                } finally {
                    setIsSyncing(false);
                }
            };

            const handleLogout = async () => {
                // Limpiar la base de datos local para cerrar sesión de forma segura
                await db.delete(); // Borra toda la base de datos
                await db.open(); // La vuelve a crear vacía
                
                setUser(null);
                setToast({ message: 'Sesión cerrada y datos locales limpiados', type: 'info' });
                setPageHistory(['login']);
            };

            
            const SyncProgressModal = ({ isSyncing, progress }) => {
                if (!isSyncing) return null;
                return (
                    <div className="fixed inset-0 bg-black bg-opacity-60 flex justify-center items-center z-50 p-4">
                        <div className="bg-white rounded-2xl shadow-xl w-full max-w-sm p-6">
                            <h3 className="font-bold text-lg mb-4">Sincronizando...</h3>
                            <div className="space-y-2">
                                <p>Clientes: {progress.clientes?.current}/{progress.clientes?.total}</p>
                                <p>Pedidos: {progress.pedidos?.current}/{progress.pedidos?.total}</p>
                                <div className="w-full bg-gray-200 rounded-full h-2.5">
                                    <div className="bg-blue-600 h-2.5 rounded-full" style={{ width: `${progress.total}%` }}></div>
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            // --- NUEVO: FUNCIÓN PARA BACKUP AUTOMÁTICO ---
            const backupCriticalData = async () => {
                try {
                    const criticalData = {
                        timestamp: new Date().toISOString(),
                        clientes: await db.clientes.toArray(),
                        pedidos: await db.pedidos.toArray(),
                        productos: await db.productos.toArray(),
                        meta: await db.meta.toArray()
                    };
                    
                    localStorage.setItem('distribuidora_backup', JSON.stringify(criticalData));
                    console.log('Backup automático completado');
                } catch (error) {
                    console.error('Error en backup automático:', error);
                }
            };

            // --- NUEVO: FUNCIÓN PARA RESTAURAR DATOS ---
            const restoreFromBackup = async () => {
                try {
                    const backup = localStorage.getItem('distribuidora_backup');
                    if (backup) {
                        const data = JSON.parse(backup);
                        const backupAge = Date.now() - new Date(data.timestamp).getTime();
                        
                        // Solo restaurar si el backup tiene menos de 24 horas
                        if (backupAge < 24 * 60 * 60 * 1000) {
                            await db.transaction('rw', db.clientes, db.pedidos, db.productos, db.meta, async () => {
                                await db.clientes.bulkPut(data.clientes);
                                await db.pedidos.bulkPut(data.pedidos);
                                await db.productos.bulkPut(data.productos);
                                await db.meta.bulkPut(data.meta);
                            });
                            console.log('Datos restaurados desde backup');
                            return true;
                        }
                    }
                    return false;
                } catch (error) {
                    console.error('Error restaurando desde backup:', error);
                    return false;
                }
            };

            // --- NUEVO: FUNCIÓN PARA LIMPIAR PEDIDOS HUÉRFANOS ---
            const cleanupOrphanedPedidos = async () => {
                try {
                    // Buscar pedidos que tienen cliente_local_id pero el cliente no existe
                    const pedidos = await db.pedidos.where('cliente_local_id').notEqual(null).toArray();
                    for (const pedido of pedidos) {
                        const cliente = await db.clientes.where('local_id').equals(pedido.cliente_local_id).first();
                        if (!cliente) {
                            console.warn('Pedido huérfano encontrado, preservando información:', pedido.local_id);
                            
                            // Extraer información útil del pedido huérfano
                            const clienteInfo = {
                                nombre_comercio: `[CLIENTE NO ENCONTRADO - ID: ${pedido.cliente_local_id}]`,
                                direccion: 'Dirección no disponible',
                                nombre_contacto: 'Contacto no disponible',
                                telefono: 'N/A',
                                local_id: pedido.cliente_local_id,
                                id: null,
                                status: 'orphaned',
                                is_orphaned: true
                            };
                            
                            // Crear un cliente "fantasma" para preservar el pedido
                            await db.clientes.put(clienteInfo);
                            
                            // Actualizar el pedido para que apunte al cliente fantasma
                            await db.pedidos.update(pedido.local_id, { 
                                cliente_local_id: pedido.cliente_local_id,
                                status: 'pending_sync',
                                notas_entrega: `[PEDIDO HUÉRFANO - Cliente original perdido] ${pedido.notas_entrega || ''}`
                            });
                        }
                    }
                } catch (error) {
                    console.error('Error procesando pedidos huérfanos:', error);
                }
            };

            // --- NUEVO: MOTOR DE SINCRONIZACIÓN INTELIGENTE ---
            const handleSync = async () => {
                if (isSyncing || !navigator.onLine) return;
                const token = (await db.meta.get('token'))?.value;
                if (!token) return;

                setIsSyncing(true);
                setToast({ message: 'Iniciando sincronización...', type: 'info' });

                // Backup automático antes de sincronizar
                await backupCriticalData();
                
                // Limpiar pedidos huérfanos antes de sincronizar
                await cleanupOrphanedPedidos();

                const maxRetries = 3;
                const retryDelay = (attempt) => Math.min(1000 * Math.pow(2, attempt), 30000); // Backoff exponencial

                try {
                    // FASE 1: Subir clientes pendientes
                    const clientesPendientes = await db.clientes.where('status').anyOf('pending_sync', 'sync_failed').toArray();
                    for (const cliente of clientesPendientes) {
                        let attempt = cliente.retries || 0;
                        if (attempt >= maxRetries) continue;

                        try {
                            const { local_id, status, retries, ...clienteData } = cliente;
                            const response = await fetch(`${API_URL}/clientes`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
                                body: JSON.stringify(clienteData)
                            });
                            if (response.ok) {
                                const newCliente = await response.json();
                                // Actualizar el cliente con el ID del servidor
                                await db.clientes.update(local_id, { 
                                    id: newCliente.id, 
                                    status: 'synced', 
                                    retries: 0 
                                });
                                
                                // Actualizar todos los pedidos que referencian este cliente local
                                const pedidosAfectados = await db.pedidos.where('cliente_local_id').equals(local_id).toArray();
                                for (const pedido of pedidosAfectados) {
                                    await db.pedidos.update(pedido.local_id, { 
                                        cliente_id: newCliente.id,
                                        cliente_local_id: null // Limpiar la referencia local
                                    });
                                }
                            } else {
                                throw new Error('Error al sincronizar cliente');
                            }
                        } catch (err) {
                            console.error('Error sincronizando cliente:', err);
                            await db.clientes.update(cliente.local_id, { 
                                status: 'sync_failed',
                                retries: (cliente.retries || 0) + 1 
                            });
                        }
                    }

                    // FASE 2: Subir pedidos pendientes
                    const pedidosPendientes = await db.pedidos.where('status').anyOf('pending_sync', 'sync_failed').toArray();
                    for (const pedido of pedidosPendientes) {
                        let attempt = pedido.retries || 0;
                        if (attempt >= maxRetries) continue;

                        try {
                            // Preparar datos del pedido para enviar al servidor
                            const { local_id, status, retries, cliente_local_id, ...pedidoData } = pedido;
                            
                            // Si el pedido tiene cliente_local_id pero no cliente_id, intentar resolverlo
                            if (pedido.cliente_local_id && !pedido.cliente_id) {
                                const clienteLocal = await db.clientes.where('local_id').equals(pedido.cliente_local_id).first();
                                if (clienteLocal && clienteLocal.id) {
                                    pedidoData.cliente_id = clienteLocal.id;
                                }
                            }
                            
                            // Solo sincronizar si tenemos un cliente_id válido
                            if (!pedidoData.cliente_id) {
                                console.warn('Pedido sin cliente_id válido, saltando sincronización:', pedido.local_id);
                                continue;
                            }

                            const response = await fetch(`${API_URL}/pedidos`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${token}` },
                                body: JSON.stringify(pedidoData)
                            });
                            if (response.ok) {
                                const newPedido = await response.json();
                                await db.pedidos.update(pedido.local_id, { 
                                    id: newPedido.id, 
                                    status: 'synced', 
                                    retries: 0 
                                });
                            } else {
                                throw new Error('Error al sincronizar pedido');
                            }
                        } catch (err) {
                            console.error('Error sincronizando pedido:', err);
                            await db.pedidos.update(pedido.local_id, { 
                                status: 'sync_failed', 
                                retries: (pedido.retries || 0) + 1 
                            });
                        }
                    }

                    // FASE 3: Descargar datos actualizados del servidor
                    const [clientesRes, productosRes] = await Promise.all([
                        fetch(`${API_URL}/clientes`, { headers: { Authorization: `Bearer ${token}` } }),
                        fetch(`${API_URL}/productos`, { headers: { Authorization: `Bearer ${token}` } })
                    ]);
                    
                    if (!clientesRes.ok || !productosRes.ok) throw new Error('Error al descargar listas.');
                    
                    const clientesData = await clientesRes.json();
                    const productosData = await productosRes.json();

                    // Download images with error handling
                    for (const producto of productosData) {
                        if (producto.imagen_url) {
                            try {
                                const response = await fetch(producto.imagen_url);
                                if (response.ok) {
                                    const blob = await response.blob();
                                    producto.imagen_blob = blob;
                                }
                            } catch (error) {
                                console.warn(`Failed to download image for product ${producto.id}:`, error);
                                // Continue without the image
                            }
                        }
                    }

                    await db.transaction('rw', db.clientes, db.productos, async () => {
                        // Actualizar clientes del servidor, preservando los locales
                        for (const cliente of clientesData) {
                            const existingCliente = await db.clientes.where('id').equals(cliente.id).first();
                            if (existingCliente) {
                                // Actualizar cliente existente
                                await db.clientes.update(existingCliente.local_id, { ...cliente, status: 'synced' });
                            } else {
                                // Agregar nuevo cliente del servidor
                                await db.clientes.add({ ...cliente, local_id: cliente.id, status: 'synced' });
                            }
                        }
                        
                        await db.productos.bulkPut(productosData);
                    });

                    const now = new Date().toISOString();
                    await db.meta.put({ key: 'lastSyncTime', value: now });
                    setLastSyncTime(now);
                    setToast({ message: 'Sincronización completada', type: 'success' });
                } catch (err) {
                    console.error('Error en sincronización:', err);
                    setToast({ message: `Error de Sincronización: ${err.message}`, type: 'error' });
                    
                    // Intentar restaurar desde backup si hay un error crítico
                    if (err.message.includes('database') || err.message.includes('IndexedDB')) {
                        const restored = await restoreFromBackup();
                        if (restored) {
                            setToast({ message: 'Datos restaurados desde backup', type: 'info' });
                        }
                    }
                } finally {
                    setIsSyncing(false);
                }
            };

            // REEMPLAZA la función handleSaveCliente por esta versión definitiva

            const handleSaveCliente = async (formData) => {
                // Validar que los datos requeridos estén presentes
                if (!formData.nombre_comercio || !formData.nombre_contacto) {
                    setToast({ message: 'Nombre del comercio y contacto son obligatorios', type: 'error' });
                    return;
                }

                const newCliente = {
                    ...formData, // Los datos del formulario (nombre, dirección, etc.)
                    local_id: `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`, // ID único y temporal para uso offline
                    id: null, // El ID del servidor es nulo porque aún no se ha sincronizado
                    status: 'pending_sync', // Marcamos este cliente para que el motor lo sincronice
                    retries: 0 // Inicializar contador de reintentos
                };

                try {
                    // Verificar si ya existe un cliente con el mismo nombre
                    const existingCliente = await db.clientes.where('nombre_comercio').equals(formData.nombre_comercio).first();
                    if (existingCliente) {
                        setToast({ message: 'Ya existe un cliente con ese nombre', type: 'error' });
                        return;
                    }

                    // Le decimos a la base de datos local que agregue este nuevo cliente.
                    await db.clientes.add(newCliente);

                    // Informamos al usuario que todo salió bien.
                    setToast({ message: 'Cliente guardado localmente. Se sincronizará cuando haya conexión.', type: 'success' });
                    
                    // Volvemos a la lista de clientes.
                    navigateBack(); 
                    
                    // Intentamos una sincronización inmediata (si hay internet, se subirá ahora mismo).
                    if (navigator.onLine) {
                        handleSync(); 
                    }
                } catch (error) {
                    console.error("Error al guardar cliente en Dexie:", error);
                    setToast({ message: 'No se pudo guardar el cliente localmente.', type: 'error' });
                }
            };

             // MEJORA: Lógica de guardado y actualización de pedidos
            const handleSavePedido = async (notas) => {
                if (currentPedido.length === 0) return;

                // Validar que tenemos un cliente seleccionado
                if (!selectedCliente) {
                    setToast({ message: 'Debe seleccionar un cliente', type: 'error' });
                    return;
                }

                // Si estamos editando un pedido existente...
                if (editingPedido) {
                    const pedidoActualizado = {
                        ...editingPedido, // Mantiene el local_id y otros datos originales
                        cliente_id: selectedCliente.id,
                        cliente_local_id: selectedCliente.local_id,
                        items: currentPedido.map(item => ({
                            producto_id: item.producto.id,
                            cantidad: item.cantidad,
                            precio_congelado: item.producto.precio_unitario
                        })),
                        notas_entrega: notas,
                        status: 'pending_sync', // Lo marca de nuevo para sincronizar
                        retries: 0 // Reiniciar contador de reintentos
                    };
                    await db.pedidos.put(pedidoActualizado);
                    setToast({ message: 'Pedido actualizado. Se sincronizará cuando haya conexión.', type: 'success' });
                } else {
                    // Si es un pedido nuevo...
                    const nuevoPedido = {
                        local_id: `local_pedido_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        cliente_id: selectedCliente.id,
                        cliente_local_id: selectedCliente.local_id,
                        vendedor_id: user ? user.id : 'offline',
                        fecha: new Date().toISOString(),
                        items: currentPedido.map(item => ({
                            producto_id: item.producto.id,
                            cantidad: item.cantidad,
                            precio_congelado: item.producto.precio_unitario
                        })),
                        notas_entrega: notas,
                        status: 'pending_sync',
                        retries: 0 // Inicializar contador de reintentos
                    };
                    await db.pedidos.add(nuevoPedido);
                    setToast({ message: 'Pedido guardado. Se sincronizará cuando haya conexión.', type: 'success' });
                }

                // Limpiamos todo para el próximo pedido
                setCurrentPedido([]);
                setSelectedCliente(null);
                setEditingPedido(null);
                setPageHistory(['home']);
                
                // Intentar sincronización inmediata solo si hay conexión
                if (navigator.onLine) {
                    handleSync();
                }
            };

            // NUEVO: Lógica para cancelar la edición
            const onCancelEdit = () => {
                setEditingPedido(null);
                setCurrentPedido([]);
                setSelectedCliente(null);
                setPageHistory(['pendientes']); // Navega explícitamente a la lista de pedidos pendientes
            };

            // MEJORA: Lógica para seleccionar un cliente
            const handleSelectCliente = (cliente) => {
                // Si ya hay un pedido en curso para OTRO cliente, se pregunta si se quiere descartar.
                if (currentPedido.length > 0 && selectedCliente?.local_id !== cliente.local_id) {
                    if (!window.confirm('Tienes un pedido sin guardar. ¿Quieres descartarlo y empezar uno nuevo para este cliente?')) {
                        return; // No hace nada si el usuario cancela
                    }
                }
                setSelectedCliente(cliente);
                // Si no hay un pedido en curso, se inicia uno vacío. Si lo había, se mantiene (memoria temporal).
                if (selectedCliente?.local_id !== cliente.local_id) {
                    setCurrentPedido([]);
                }
                setEditingPedido(null);
                navigateTo('pedido');
            };
            
            // AGREGA esta nueva función dentro del componente App
            const handleSaveQuantity = (product, quantity) => {
                setCurrentPedido(current => {
                    const existingItem = current.find(item => item.producto.id === product.id);
                    if (quantity > 0) {
                        if (existingItem) {
                            // Si el item ya existe, actualiza su cantidad
                            return current.map(item => item.producto.id === product.id ? { ...item, cantidad: quantity } : item);
                        }
                        // Si es un item nuevo, lo agrega al carrito
                        return [...current, { producto: product, cantidad: quantity }];
                    } else {
                        // Si la cantidad es 0, quita el item del carrito
                        return current.filter(item => item.producto.id !== product.id);
                    }
                });
                setProductForQuantity(null); // Cierra el modal
            };

            // AGREGA estas dos nuevas funciones dentro del componente App

            const onDeletePedido = async (localId) => {
                try {
                    await db.pedidos.delete(localId);
                    setToast({ message: 'Pedido eliminado permanentemente', type: 'success' });
                } catch (error) {
                    console.error("Error al eliminar pedido:", error);
                    setToast({ message: 'No se pudo eliminar el pedido.', type: 'error' });
                }
            };

            // NUEVO: Función para manejar notas rápidas
            const handleQuickNote = async (noteText) => {
                try {
                    const note = {
                        id: `note_${Date.now()}`,
                        text: noteText,
                        fecha: new Date().toISOString(),
                        user: user?.nombre || 'Offline'
                    };
                    
                    // Guardar en la base de datos local
                    await db.meta.put({ key: `quick_note_${note.id}`, value: note });
                    
                    setToast({ message: 'Nota guardada', type: 'success' });
                } catch (error) {
                    console.error("Error guardando nota:", error);
                    setToast({ message: 'No se pudo guardar la nota', type: 'error' });
                }
            };

            const onEditPedido = async (pedido) => {
                const clientes = await db.clientes.toArray();
                const productos = await db.productos.toArray();

                // Usamos la misma lógica inteligente para encontrar el cliente
                const clienteDelPedido = clientes.find(c => (c.id && c.id === pedido.cliente_id) || c.local_id === pedido.cliente_local_id);
                
                if (!clienteDelPedido) {
                    setToast({ message: 'No se pueden cargar los datos del cliente para editar.', type: 'error' });
                    return;
                }

                const carritoConProductos = pedido.items.map(item => ({
                    producto: productos.find(p => p.id === item.producto_id),
                    cantidad: item.cantidad
                })).filter(item => item.producto); // Filtra por si un producto fue eliminado

                setSelectedCliente(clienteDelPedido);
                setEditingPedido(pedido); // Marcamos que estamos editando
                setCurrentPedido(carritoConProductos); // Cargamos el carrito
                navigateTo('pedido_summary');
            };

            // --- RENDERIZADO DE VISTAS ---
            const renderPage = () => {
                switch (currentPage) {
                    case 'loading':
                        return <div className="flex h-screen items-center justify-center"><Spinner className="border-blue-600 h-10 w-10"/></div>;
                    case 'home':
                        return <VendedorHomePage user={user} navigateTo={navigateTo} pendingCount={pendingCount} />;
                    case 'login':
                        return <LoginPage onLogin={handleLogin} loading={isSyncing} error={toast?.message} onBack={() => setPageHistory(['home'])} />;
                    case 'clientes':
                        return <ClientesView onBack={navigateBack} onSelectCliente={(cliente) => { setSelectedCliente(cliente); setCurrentPedido([]); setEditingPedido(null); navigateTo('pedido'); }} onAddCliente={() => { setEditingCliente(null); navigateTo('cliente_form'); }} />;
                    case 'cliente_form':
                        return <ClienteFormView onBack={navigateBack} cliente={editingCliente} onSave={handleSaveCliente} />;
                    case 'pedido':
                        return <PedidoView cliente={selectedCliente} onBack={(cart) => { setCurrentPedido(cart); navigateBack(); }} onShowCart={(cart) => { setCurrentPedido(cart); navigateTo('pedido_summary'); }} cart={currentPedido} onProductSelect={(product) => setProductForQuantity(product)} />;
                    case 'pedido_summary':
                        return <PedidoSummaryView cliente={selectedCliente} pedido={currentPedido} setPedido={setCurrentPedido} onBack={(cart) => { setCurrentPedido(cart); navigateTo('pedido'); }} onSave={handleSavePedido} onAddMoreProducts={(cart) => { setCurrentPedido(cart); navigateTo('pedido'); }} />;
                    case 'pendientes':
                        return <PedidosPendientesView onBack={navigateBack} onSync={handleSync} isSyncing={isSyncing} onEditPedido={onEditPedido} onViewPedido={(p) => { setSelectedPedido(p); navigateTo('pedido_detail'); }} onDeletePedido={onDeletePedido} user={user} onLoginRequest={() => navigateTo('login')} />;
                    case 'historial':
                        return <HistorialClienteView cliente={selectedCliente} onBack={navigateBack} onViewPedido={(pedido) => { setSelectedPedido(pedido); navigateTo('pedido_detail'); }} />;
                    case 'pedido_detail':
                        return <PedidoDetailView pedido={selectedPedido} onBack={navigateBack} />;
                    default:
                        return <VendedorHomePage user={user} navigateTo={navigateTo} pendingCount={pendingCount} />;
                }
            };

            // --- NUEVO: SISTEMA DE MODO OFFLINE MEJORADO ---
            const [offlineMode, setOfflineMode] = React.useState(!navigator.onLine);
            const [lastSyncAttempt, setLastSyncAttempt] = React.useState(null);
            const [syncRetryCount, setSyncRetryCount] = React.useState(0);

            // Monitoreo de estado de conexión
            React.useEffect(() => {
                const handleOnline = () => {
                    setOfflineMode(false);
                    setToast({ message: 'Conexión restaurada. Sincronizando...', type: 'info' });
                    // Intentar sincronización automática cuando se recupera la conexión
                    setTimeout(handleSync, 1000);
                };
                
                const handleOffline = () => {
                    setOfflineMode(true);
                    setToast({ message: 'Modo offline activado. Los datos se guardarán localmente.', type: 'info' });
                };
                
                window.addEventListener('online', handleOnline);
                window.addEventListener('offline', handleOffline);
                
                return () => {
                    window.removeEventListener('online', handleOnline);
                    window.removeEventListener('offline', handleOffline);
                };
            }, []);

            // Sincronización automática con reintentos inteligentes
            const autoSync = async () => {
                if (isSyncing || !navigator.onLine || !user) return;
                
                const now = Date.now();
                const timeSinceLastAttempt = lastSyncAttempt ? now - lastSyncAttempt : Infinity;
                
                // Esperar al menos 30 segundos entre intentos
                if (timeSinceLastAttempt < 30000) return;
                
                setLastSyncAttempt(now);
                setSyncRetryCount(prev => prev + 1);
                
                try {
                    await handleSync();
                    setSyncRetryCount(0); // Reset contador si la sincronización fue exitosa
                } catch (error) {
                    console.error('Auto-sync failed:', error);
                    // Si falla más de 5 veces, aumentar el intervalo
                    if (syncRetryCount > 5) {
                        setTimeout(autoSync, 5 * 60 * 1000); // 5 minutos
                    } else {
                        setTimeout(autoSync, 2 * 60 * 1000); // 2 minutos
                    }
                }
            };

            // Auto-sync cada 5 minutos si hay conexión
            React.useEffect(() => {
                if (!navigator.onLine || !user) return;
                
                const interval = setInterval(autoSync, 5 * 60 * 1000);
                return () => clearInterval(interval);
            }, [user, navigator.onLine]);

            return (
                <div id="main-app" className="no-print relative">
                    <ConnectionStatus />
                    {renderPage()}
                    {toast && <Toast message={toast.message} type={toast.type} onClose={() => setToast(null)} />}
                    {productForQuantity && (
                        <QuantityModal
                            product={productForQuantity}
                            existingQuantity={(currentPedido.find(item => item.producto.id === productForQuantity.id) || {}).cantidad || 0}
                            onSave={handleSaveQuantity}
                            onCancel={() => setProductForQuantity(null)}
                        />
                    )}
                    <QuickNotesModal 
                        isOpen={showQuickNotes}
                        onClose={() => setShowQuickNotes(false)}
                        onSave={handleQuickNote}
                    />
                    <SyncProgressModal isSyncing={isSyncing} progress={syncProgress} />
                </div>
            );
        }

        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
    <script>
        // Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then(reg => console.log('SW Registrado!', reg))
                    .catch(err => console.log('Error SW:', err));
            });
        }
        
        // Cordova specific initialization
        document.addEventListener('deviceready', function() {
            console.log('Cordova is ready!');
            
            // Prevent zoom on double tap
            document.addEventListener('touchstart', function(event) {
                if (event.touches.length > 1) {
                    event.preventDefault();
                }
            }, { passive: false });
            
            // Prevent zoom on double tap
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function(event) {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    event.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
            
        }, false);
        
        // Handle back button in Cordova
        document.addEventListener('backbutton', function() {
            // This will be handled by React navigation
            window.history.back();
        }, false);
    </script>
</body>
</html>